#!/usr/bin/env python
import itertools
import os
import sys

from utils import BinUncertaintyError, BinWidthError, \
     autocategorizer, parse_rebinning_trees, rebin


def parse_command_line(argv):
    """Parse the command line for the configuration file."""
    if argv is None:
        argv = sys.argv
    if len(argv) < 2:
        raise RuntimeError('No configuration file provided')
    else:
        config_file = os.path.basename(sys.argv[1])
        module_name, _ = os.path.splitext(config_file)
        try:
            config = __import__(module_name, globals(), locals(), [])
        except ImportError:
            raise
        return config


def main(argv=None):
    sys.dont_write_bytecode = True
    config = parse_command_line(argv)
    target, target_min, target_max = config.target

    # Create a vector tracking the names of the rebinning features.
    features = autocategorizer.Features(target)

    # Load events from each of the samples to form a vector of rebinning events.
    events = autocategorizer.Events()
    for sample in config.samples:
        autocategorizer.loadEvents(events, features, config.input_pattern % sample, config.treename, config.aliases)
    print '  /// Loaded {0!s} training events'.format(events.size())

    # Run the rebinning routine.
    N_BINS = config.settings['n_bins']
    METRICS = config.settings['metrics']
    N_MINBKG = config.settings['n_minbkg']
    SMOOTH_BKG = config.settings['smooth_bkg']
    UNC_TOL = config.settings['unc_tol']
    WIDTH_TOL = config.settings['width_tol']

    trial_params = itertools.product(N_BINS, METRICS, N_MINBKG, SMOOTH_BKG, UNC_TOL, WIDTH_TOL)
    for n_bins, metric, n_minbkg, smooth_bkg, unc_tol, width_tol in trial_params:
        print '\nRebinning with n_bins={0!s}, metric={1}, n_minbkg={2!s}, smooth_bkg={3!r}, unc_tol={4!s}, width_tol={5!s}'.format(n_bins, metric, n_minbkg, smooth_bkg, unc_tol, width_tol)
        try:
            results = rebin(events, features, n_bins, metric, n_minbkg, smooth_bkg, unc_tol, [target_min, target_max, width_tol], config.destination)
            for key, value in sorted(results.items(), key=lambda x: x[0]):
                print '{0!s}: {1!r}'.format(key, value)
        except BinUncertaintyError:
            print '... failed relative uncertainty tolerance!'
        except BinWidthError:
            print '... failed relative width tolerance!'
        except Exception:
            raise

    # Parse the rebinning XML files and report the rebinning
    # schemes with the highest significance scores.
    results = parse_rebinning_trees(config.destination, bounds=[target_min, target_max])

    best_poisson_index = results.loc[results.metric == 'poisson']['total_significance'].idxmax()
    best_poisson_trial = results.loc[results.metric == 'poisson'].loc[best_poisson_index]

    best_asimov_index = results.loc[results.metric == 'asimov']['total_significance'].idxmax()
    best_asimov_trial = results.loc[results.metric == 'asimov'].loc[best_asimov_index]

    for i, trial in enumerate([best_asimov_trial, best_poisson_trial]):
        print '\nBest {0} Rebinning Scheme'.format('Poisson' if i else 'Asimov')
        print '--------------------------------------------------------'
        print 'Number of Final Bins: {0!s}'.format(trial.n_bins)
        print 'Minimum Number of Background Events (Unweighted): {0!s}'.format(trial.n_minbkg)
        print 'Background Smoothing Applied: {0!r}'.format(trial.smooth_bkg)
        print 'Maximum Relative Background Stat. Uncertainty: {0!s}'.format(trial.unc_tol)
        print 'Minimum Bin Width Relative to Full Range: {0!s}'.format(trial.width_tol)
        print 'Total Significance Score: {0!s}'.format(trial.total_significance)
        print 'Bin Edges: {0!s}'.format(trial.bin_edges)


if __name__ == '__main__':

    status = main()
    sys.exit(status)

